// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//
//@@@@@@@@&....(@@@@@@@@@@@@@..../@@@@@@@@@//
//@@@@@@........../@@@@@@@........../@@@@@@//
//@@@@@............(@@@@@............(@@@@@//
//@@@@@(............@@@@@(...........&@@@@@//
//@@@@@@@...........&@@@@@@.........@@@@@@@//
//@@@@@@@@@@@@@@%..../@@@@@@@@@@@@@@@@@@@@@//
//@@@@@@@@@@@@@@@@@@@...@@@@@@@@@@@@@@@@@@@//
//@@@@@@@@@@@@@@@@@@@@@......(&@@@@@@@@@@@@//
//@@@@@@#.........@@@@@@#...........@@@@@@@//
//@@@@@/...........%@@@@@............%@@@@@//
//@@@@@............#@@@@@............%@@@@@//
//@@@@@@..........#@@@@@@@/.........#@@@@@@//
//@@@@@@@@@&/.(@@@@@@@@@@@@@@&/.(&@@@@@@@@@//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//

import {INFTPoolFactory, INFTPool, INFTHandler} from "./interfaces/CamelotInterfaces.sol";
import {BaseFarm, RewardTokenData} from "../BaseFarm.sol";

/// @title Demeter_CamelotFarm
/// @notice This contract represents a Camelot farm where users can stake and lock NFTs to earn rewards.
/// @dev It inherits from BaseFarm and implements the INFTHandler interface for NFT handling.
contract Demeter_CamelotFarm is BaseFarm, INFTHandler {
    // Constants
    string public constant FARM_ID = "Demeter_Camelot_v1";
    address public constant NFT_POOL_FACTORY =
        0x6dB1EF0dF42e30acF139A70C1Ed0B7E6c51dBf6d;

    // Camelot NFT pool
    address public nftPool;

    event PoolRewardsCollected(
        address indexed recipient,
        uint256 indexed tokenId,
        uint256 grailAmt,
        uint256 xGrailAmt
    );

    // Custom Errors
    error InvalidCamelotPoolConfig();
    error NotACamelotNFT();
    error NoData();
    error NotAllowed();

    /// @notice Initializes the Camelot farm.
    /// @param _farmStartTime The time when the farm starts.
    /// @param _cooldownPeriod The cooldown period for locked deposits in days.
    /// @param _camelotPairPool The Camelot LP pool address.
    /// @param _rwdTokenData Initial data for reward tokens.
    /// @dev Set _cooldownPeriod = 0 to disable lockup functionality for the farm.
    function initialize(
        uint256 _farmStartTime,
        uint256 _cooldownPeriod,
        address _camelotPairPool,
        RewardTokenData[] memory _rwdTokenData
    ) external initializer {
        // Initialize the NFT pool address.
        nftPool = INFTPoolFactory(NFT_POOL_FACTORY).getPool(_camelotPairPool);
        if (nftPool == address(0)) {
            revert InvalidCamelotPoolConfig();
        }

        // Setup the farm using provided data.
        _setupFarm(_farmStartTime, _cooldownPeriod, _rwdTokenData);
    }

    /// @notice Function called when a user transfers an NFT to the contract.
    /// @param _from The address of the NFT owner.
    /// @param _tokenId The NFT ID generated by Camelot.
    /// @param _data The data should be the lockup flag (bool).
    /// @return The selector of the ERC721Receiver function.
    function onERC721Received(
        address, // unused variable, not named
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    ) external override returns (bytes4) {
        if (msg.sender != nftPool) {
            revert NotACamelotNFT();
        }
        if (_data.length == 0) {
            revert NoData();
        }
        uint256 liquidity = _getLiquidity(_tokenId);
        // Execute the common deposit function.
        _deposit(_from, abi.decode(_data, (bool)), _tokenId, liquidity);
        return this.onERC721Received.selector;
    }

    /// @notice Function to initiate the cooldown for a locked deposit.
    /// @param _depositId The ID of the deposit to be locked.
    function initiateCooldown(uint256 _depositId) external nonReentrant {
        _initiateCooldown(_depositId);
    }

    /// @notice Function to withdraw a deposit from the farm.
    /// @param _depositId The ID of the deposit to be withdrawn.
    function withdraw(uint256 _depositId) external nonReentrant {
        address account = msg.sender;
        _isValidDeposit(account, _depositId);
        Deposit memory userDeposit = deposits[account][_depositId];

        _withdraw(msg.sender, _depositId, userDeposit);
        // Transfer the NFT back to the user.
        INFTPool(nftPool).safeTransferFrom(
            address(this),
            account,
            userDeposit.tokenId
        );
    }

    /// @notice Function to claim pool rewards for a deposit.
    /// @param _depositId The ID of the deposit.
    function claimPoolRewards(uint256 _depositId) external nonReentrant {
        _farmNotClosed();
        address account = msg.sender;
        _isValidDeposit(account, _depositId);
        INFTPool(nftPool).harvestPositionTo(
            deposits[account][_depositId].tokenId,
            account
        );
    }

    /// @notice Callback function for harvestPosition().
    /// @param _to The address receiving the rewards.
    /// @param _tokenId The ID of the NFT position.
    /// @param _grailAmount The amount of Grail rewards.
    /// @param _xGrailAmount The amount of xGrail rewards.
    /// @return true if the callback was successful.
    function onNFTHarvest(
        address, // unused variable, not named
        address _to,
        uint256 _tokenId,
        uint256 _grailAmount,
        uint256 _xGrailAmount
    ) external override returns (bool) {
        if (msg.sender != nftPool) {
            revert NotAllowed();
        }
        emit PoolRewardsCollected(_to, _tokenId, _grailAmount, _xGrailAmount);
        return true;
    }

    /// @notice Get the accrued pool rewards for a deposit.
    /// @param _tokenId The ID of the NFT position.
    /// @return amount The amount of Grail rewards.
    function computePoolRewards(uint256 _tokenId)
        external
        view
        returns (uint256 amount)
    {
        // Validate the NFT token.
        amount = INFTPool(nftPool).pendingRewards(_tokenId);
        return amount;
    }

    /// @notice Validate the NFT position for the pool and get liquidity.
    /// @param _tokenId The ID of the NFT position.
    /// @return liquidity The liquidity of the NFT position.
    function _getLiquidity(uint256 _tokenId) private view returns (uint256) {
        // Get the info of the required token
        (uint256 liquidity, , , , , , , ) = INFTPool(nftPool)
            .getStakingPosition(_tokenId);

        return liquidity;
    }
}
