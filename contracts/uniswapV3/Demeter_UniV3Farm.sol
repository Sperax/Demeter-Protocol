// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//
//@@@@@@@@&....(@@@@@@@@@@@@@..../@@@@@@@@@//
//@@@@@@........../@@@@@@@........../@@@@@@//
//@@@@@............(@@@@@............(@@@@@//
//@@@@@(............@@@@@(...........&@@@@@//
//@@@@@@@...........&@@@@@@.........@@@@@@@//
//@@@@@@@@@@@@@@%..../@@@@@@@@@@@@@@@@@@@@@//
//@@@@@@@@@@@@@@@@@@@...@@@@@@@@@@@@@@@@@@@//
//@@@@@@@@@@@@@@@@@@@@@......(&@@@@@@@@@@@@//
//@@@@@@#.........@@@@@@#...........@@@@@@@//
//@@@@@/...........%@@@@@............%@@@@@//
//@@@@@............#@@@@@............%@@@@@//
//@@@@@@..........#@@@@@@@/.........#@@@@@@//
//@@@@@@@@@&/.(@@@@@@@@@@@@@@&/.(&@@@@@@@@@//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//

import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import {INonfungiblePositionManager as INFPM, IUniswapV3Factory, IUniswapV3TickSpacing, CollectParams} from "./interfaces/UniswapV3.sol";
import {PositionValue} from "./libraries/PositionValue.sol";
import {BaseFarm, RewardTokenData} from "../BaseFarm.sol";

/**
 * @notice Defines the initialization data for a Uniswap pool in the constructor.
 * @param tokenA Address of tokenA - the first token in the Uniswap pool.
 * @param tokenB Address of tokenB - the second token in the Uniswap pool.
 * @param feeTier Fee tier for the Uniswap pool.
 * @param tickLowerAllowed Lower bound of the tick range allowed for the farm.
 * @param tickUpperAllowed Upper bound of the tick range allowed for the farm.
 */
struct UniswapPoolData {
    address tokenA;
    address tokenB;
    uint24 feeTier;
    int24 tickLowerAllowed;
    int24 tickUpperAllowed;
}

/**
 * @title Demeter_UniV3Farm
 * @notice This contract represents a Uniswap V3 farm that allows users to stake NFT liquidity positions.
 */
contract Demeter_UniV3Farm is BaseFarm, IERC721Receiver {
    // Constants
    string public constant FARM_ID = "Demeter_UniV3_v3";
    address public constant NFPM = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;
    address public constant UNIV3_FACTORY =
        0x1F98431c8aD98523631AE4a59f267346ea31F984;

    // UniswapV3 parameters
    int24 public tickLowerAllowed;
    int24 public tickUpperAllowed;
    address public uniswapPool;

    event PoolFeeCollected(
        address indexed recipient,
        uint256 tokenId,
        uint256 amt0Recv,
        uint256 amt1Recv
    );

    // Custom Errors
    error InvalidUniswapPoolConfig();
    error NotAUniV3NFT();
    error NoData();
    error NoFeeToClaim();
    error IncorrectPoolToken();
    error IncorrectTickRange();
    error InvalidTickRange();

    /**
     * @notice Initializes the farm with parameters.
     * @param _farmStartTime The time of farm start.
     * @param _cooldownPeriod The cooldown period for locked deposits in days.
     * @dev A `_cooldownPeriod` of 0 disables lockup functionality for the farm.
     * @param _uniswapPoolData The initialization data for the UniswapV3 pool.
     * @param _rwdTokenData The initialization data for reward tokens.
     */
    function initialize(
        uint256 _farmStartTime,
        uint256 _cooldownPeriod,
        UniswapPoolData memory _uniswapPoolData,
        RewardTokenData[] memory _rwdTokenData
    ) external initializer {
        // Initialize Uniswap-related data
        uniswapPool = IUniswapV3Factory(UNIV3_FACTORY).getPool(
            _uniswapPoolData.tokenB,
            _uniswapPoolData.tokenA,
            _uniswapPoolData.feeTier
        );
        if (uniswapPool == address(0)) {
            revert InvalidUniswapPoolConfig();
        }
        _validateTickRange(
            _uniswapPoolData.tickLowerAllowed,
            _uniswapPoolData.tickUpperAllowed
        );
        tickLowerAllowed = _uniswapPoolData.tickLowerAllowed;
        tickUpperAllowed = _uniswapPoolData.tickUpperAllowed;

        _setupFarm(_farmStartTime, _cooldownPeriod, _rwdTokenData);
    }

    /**
     * @notice Function is called when the user transfers the NFT to the contract.
     * @param _from The address of the owner.
     * @param _tokenId The NFT ID generated by Uniswap V3.
     * @param _data The data should be the lockup flag (bool).
     */
    function onERC721Received(
        address, // Unused variable, not named
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    ) external override returns (bytes4) {
        if (msg.sender != NFPM) {
            revert NotAUniV3NFT();
        }
        if (_data.length == 0) {
            revert NoData();
        }
        uint256 liquidity = _getLiquidity(_tokenId);

        _deposit(_from, abi.decode(_data, (bool)), _tokenId, liquidity);
        return this.onERC721Received.selector;
    }

    /**
     * @notice Function to lock a staked deposit.
     * @param _depositId The ID of the deposit to be locked.
     */
    function initiateCooldown(uint256 _depositId) external nonReentrant {
        _initiateCooldown(_depositId);
    }

    /**
     * @notice Function to withdraw a deposit from the farm.
     * @param _depositId The ID of the deposit to be withdrawn.
     */
    function withdraw(uint256 _depositId) external nonReentrant {
        address account = msg.sender;
        _isValidDeposit(account, _depositId);
        Deposit memory userDeposit = deposits[account][_depositId];

        _withdraw(msg.sender, _depositId, userDeposit);
        // Transfer the NFT back to the user.
        INFPM(NFPM).safeTransferFrom(
            address(this),
            account,
            userDeposit.tokenId
        );
    }

    /**
     * @notice Claim Uniswap pool fee for a deposit.
     * @dev Only the deposit owner can claim the fee.
     * @param _depositId Id of the deposit.
     */
    function claimUniswapFee(uint256 _depositId) external nonReentrant {
        _farmNotClosed();
        address account = msg.sender;
        _isValidDeposit(account, _depositId);
        uint256 tokenId = deposits[account][_depositId].tokenId;

        INFPM pm = INFPM(NFPM);
        (uint256 amt0, uint256 amt1) = PositionValue.fees(pm, tokenId);
        if (amt0 == 0 && amt1 == 0) {
            revert NoFeeToClaim();
        }
        (uint256 amt0Recv, uint256 amt1Recv) = pm.collect(
            CollectParams({
                tokenId: tokenId,
                recipient: account,
                amount0Max: uint128(amt0),
                amount1Max: uint128(amt1)
            })
        );
        emit PoolFeeCollected(account, tokenId, amt0Recv, amt1Recv);
    }

    /**
     * @notice Get the accrued Uniswap fee for a deposit.
     * @param _tokenId The tokenId of the position.
     * @return amount0 The amount of token0.
     * @return amount1 The amount of token1.
     */
    function computeUniswapFee(uint256 _tokenId)
        external
        view
        returns (uint256 amount0, uint256 amount1)
    {
        // Validate token.
        _getLiquidity(_tokenId);
        return PositionValue.fees(INFPM(NFPM), _tokenId);
    }

    /**
     * @notice Validate the position for the pool and get liquidity.
     * @param _tokenId The tokenId of the position.
     * @dev The position must adhere to the price ranges.
     * @dev Only allow specific pool token to be staked.
     */
    function _getLiquidity(uint256 _tokenId) private view returns (uint256) {
        // Get the info of the required token.
        (
            ,
            ,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            ,
            ,
            ,

        ) = INFPM(NFPM).positions(_tokenId);

        // Check if the token belongs to the correct pool.
        if (
            uniswapPool !=
            IUniswapV3Factory(UNIV3_FACTORY).getPool(token0, token1, fee)
        ) {
            revert IncorrectPoolToken();
        }

        // Check if the token adheres to the tick range.
        if (tickLower != tickLowerAllowed || tickUpper != tickUpperAllowed) {
            revert IncorrectTickRange();
        }

        return uint256(liquidity);
    }

    /**
     * @notice Validate the tick range for UniswapV3.
     * @param _tickLower The lower tick of the range.
     * @param _tickUpper The upper tick of the range.
     */
    function _validateTickRange(int24 _tickLower, int24 _tickUpper)
        private
        view
    {
        int24 spacing = IUniswapV3TickSpacing(uniswapPool).tickSpacing();
        if (
            !(_tickLower < _tickUpper &&
                _tickLower >= -887272 &&
                _tickLower % spacing == 0 &&
                _tickUpper <= 887272 &&
                _tickUpper % spacing == 0)
        ) {
            revert InvalidTickRange();
        }
    }
}
